---
title: "[백준] 2143 G3 두 배열의 합"
date: 2025-04-02
toc: true
ps:
  link: https://www.acmicpc.net/problem/2143
  solved: 2025-04-02
---

# 접근

## 완전 탐색으로

어렵게 생각하지 말고 무식하게 완전 탐색으로 접근해 보자.

`A` 배열에서, 모든 부 배열의 **합**과 그 **갯수**를 계산한다.  
여기에 소요되는 복잡도는, `A` 배열 범위 내 인덱스를 중복하여 두 개 뽑은 후 ($_nH_2$) 그 인덱스 범위를 더하는 것이므로, 대략적으로 $O(n_nH_2) = O(n^3)$의 복잡도이다.

`B` 배열도 마찬가지로 계산하면 $O(m^3)$정도일 것이다.

$n$과 $m$은 모두 $10^3$보다 작으므로, $O(n^3)$과 $O(m^3)$은 대략 1초 정도 소요되므로, 아직까지 복잡도에 문제는 없다.

==`A` 배열의 부 배열 합 $s_a$과 갯수 $c_a$를 순회하면서, $T$에 도달하기 위한 값 $T-s_a$가 `B`의 부 배열의 합에 존재하는지 **탐색**한다.==

존재한다면, 그 갯수 $c_b$를 $c_a$와 곱하여, 전체 갯수를 증가시킨다.

## 해시 테이블을 사용하는 이유

> ==`A` 배열의 부 배열 합 $s_a$과 갯수 $c_a$를 순회하면서, $T$에 도달하기 위한 값 $T-s_a$가 `B`의 부 배열의 합에 존재하는지 **탐색**한다.==

여기서 중요한 부분은 저 **탐색** 부분이다.

값이 존재하는지 아닌지, 탐색하는 데에 $O(1)$이 소요되는 아주 괜찮은 자료구조가 있는데 - 바로 **해시테이블**이다.

부 배열의 합과 그 합을 가지는 갯수를 저장하기 위해서 해시 테이블을 사용하면, $T$를 만들기 위해 필요한 값이 존재하는지 $O(1)$안에 확인할 수 있게 된다.

# 코드

코드는 아래와 같다.

{{< hlc "assets/code.cc" "cpp" >}}

# ⚠️ 주의 사항

## 최종 갯수의 자료형

`A`의 부 배열의 합의 최대 갯수는 대략 $\frac{n(n-1)}{2}$개, `B` 부 배열의 합의 최대 갯수는 대략 $\frac{m-1}{2}$개이다.

만일, 모든 쌍으로 $T$를 만들 수 있으면 가능한 총 갯수는 $\frac{n(n-1)(m)(m-1)}{4}$로, $10^{11}$에서 $10^{12}$ 사이의 값이 된다.

그리고, 이는 `int`형의 범위를 초과하기 때문에 최종 `count`를 기록하는 변수는 `long long`으로 설정하여 오버플로우가 발생하지 않도록 만들어야 한다.

## 부 배열의 합 로직 최적화

앞서 부 배열의 합을 구하는 것이 $O(n^3)$이라고 하였는데, 여기서 최적화를 할 수 있다.

아래가 기존의 코드이다.

```cpp
for (int i = 0; i < n; ++i) { // O(n)
  for (int j = i; j < n; ++j) { // O(n)
    int sum = 0;
    for (int c = i; c <= j; ++c) { // O(n)
      sum += A[c];
    }
    ++sumA[sum];
  }
}
```

> 이 방식의 문제는 `j`가 1씩 증가할 때마다 `i` 부터 `j`까지의 합을 처음부터 다시 계산한다는 점에 있다. `[i ... j-1]`의 합을 이미 계산했는데, `[i ... j]`의 합을 구할 때 ==이 결과를 재사용하지 않고 다시 처음부터 순회하는 것이므로 비효율적이다.==

아래처럼 하면 $O(n^2)$ 안에도 통과가 가능하다.

```cpp
for (int i = 0; i < n; ++i) {
  int sum = 0;
  for (int j = i; j < n ; ++j) {
    // [i ... j-1]에 [j] 만 더해서, [i ... j]를 구함
    sum += A[j];
    ++sumA[sum];
  }
}
```

시작 인덱스 `i`를 고정한 상태에서, `j`를 증가시키면서 합을 누적해 나간다.

두 개의 루프만으로 누적 합을 구할 수 있다.

하지만, 최적화를 하지 않아도 통과 자체는 된다. 🤷‍♂️

---
title: "[알고리즘] LIS: 최장 증가 부분 수열"
toc: true
date: 2025-04-30
---

# LIS란?

{{<admo title="LIS의 정의">}}
**최장 증가 부분 수열(LIS, Longest Increasing Subsequence)** 란, 어떤 수열의 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하면서 그 길이가 최대인 부분 수열을 말한다.

<br>
  
이러한 부분 수열은 *연속* 되거나 *유일* 할 필요는 없다.
{{</admo>}}

예를 들어, $\\{2, 3, 1, 4, 3.5\\}$라는 수열이 있는 경우, LIS는 $\\{2, 3, 4\\}$와 $\\{2, 3, 3.5\\}$이다.

# LIS의 **길이** 구하기

## 동적 계획법을 이용하여 구하기 ($O(N^2)$)

길이가 $N$인 수열이 배열 `seq`에 담겨있다고 할 때, `dp`를 다음과 같이 정의하자.

{{<admo title="`dp`의 정의">}}
`dp[i]`는 ==`seq[i]`를 마지막 요소로 하는 최장 증가 부분 수열의 길이==

(단, `dp[0] = seq[0] = 0`)
{{</admo>}}

따라서, `seq[i]`를 마지막 요소로 하는 최장 증가 부분 수열의 길이는, `seq[i]`가 추가될 수 있는 증가 부분 수열 중 가장 긴 수열의 길이에 1을 더한 값이 된다.

예를 들어 `seq = {20, 30, 10, 40, 35}`라고 하자.

`i = 0`일 때 상황은 아래와 같다.

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 |
|`dp`| 0 |  |  |  |  |  |

`i = 1`인 경우, `seq[1] = 20`을 마지막 요소로 하는 최장 증가 부분 수열의 길이는 당연히 1이다. 

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 | 
|`dp`| 0 | `1` |  |  |  |  |

`i = 2`인 경우, `seq[2] = 30`을 마지막 요소로 하는 최장 증가 부분 수열의 길이는 다음 처럼 구한다:
* `i = 1`일 때, `dp[1]`이 `seq[1] = 20`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.   
  * ==`seq[1]`이 `seq[2]`보다 작으므로, `seq[2]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다.
그러므로, `dp[2] = dp[1] + `이다.==

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 |
|`dp`| 0 | `1` | `dp[1] + 1 = 2` |  |  |  |

`i = 3`인 경우, `seq[3] = 10`을 마지막 요소로 하는 최장 증가 부분 수열의 길이는 다음 처럼 구한다:
* `i = 1`일 때 `dp[1]`이 `seq[1] = 20`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.
  * 하지만, `seq[3] = 10`이고 이는 `seq[1] = 20`보다 **작으므로**, `seq[3]`을 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 없다.
* `i = 2`일 때, `dp[2]`이 `seq[2] = 30`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 2였다.
  * 하지만, `seq[3] = 10`이고, 이는 `seq[2] = 30`보다 **작으므로**, `seq[3]`을 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 없다.
* 이전의 모든 `i`에 대해서 `seq[3]`을 붙여 연장시킬 수 없으므로, `seq[3]`부터 새로 시작하는 부분 수열을 고려해야 한다. 따라서, `dp[3] = 1`이다.

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 |
|`dp`| 0 | `1` | `dp[1] + 1 = 2` | `1` |  |  |

`i = 4`인 경우, `seq[4] = 40`을 마지막 요소로 하는 최장 증가 부분 수열의 길이는 다음처럼 구한다:
* `i = 1`일 때, `seq[1] = 20`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.
  * `seq[4] = 40`이 `seq[1] = 20`보다 **크므로**, `seq[4]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[4] = dp[1] + 1 = 2`일 수 있다.
* `i = 2`일 때, `seq[2] = 30`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 2였다.
  * `seq[4] = 40`이 `seq[1] = 20`보다 **크므로**, `seq[4]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[4] = dp[2] + 1 = 3`일 수 있다.
* `i = 3`일 때, `seq[3] = 10`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1였다.
  * `seq[3] = 40`이 `seq[3] = 10`보다 **크므로**, `seq[4]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[4] = dp[3] + 1 = 2`일 수 있다.
* 이를 종합하면, `dp[4]`는, `max(dp[1], dp[2], dp[3]) + 1`이라고 할 수 있다.

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 |
|`dp`| 0 | `1` | `dp[1] + 1 = 2` | `1` | `max(dp[1], dp[2], dp[3]) + 1` |  |

`i = 5`인 경우, `seq[5] = 35`를 마지막 요소로 하는 최장 증가 부분 수열의 길이는 다음처럼 구한다:
* `i = 1`일 때, `seq[1] = 20`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.
  * `seq[5] = 35`이 `seq[1] = 20`보다 **크므로**, `seq[5]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[5] = dp[1] + 1 = 2`일 수 있다.
* `i = 2`일 때, `seq[2] = 30`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 2이었다.
  * `seq[5] = 35`이 `seq[2] = 30`보다 **크므로**, `seq[5]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[5] = dp[2] + 1 = 3`일 수 있다.
* `i = 3`일 때, `seq[3] = 10`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.
  * `seq[5] = 35`이 `seq[3] = 10`보다 **크므로**, `seq[5]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 있다. 그러므로, `dp[5] = dp[3] + 1 = 2`일 수 있다.
* `i = 4`일 때, `seq[4] = 40`을 마지막 요소로 하였고, 이 때 최장 증가 부분 수열의 길이가 1이었다.
  * `seq[5] = 35`이 `seq[4] = 10`보다 **작으므로**, `seq[5]`를 그대로 뒤에 붙여 최장 증가 부분 수열의 길이를 연장시킬 수 없다.
* 이를 종합하면, `dp[5]`는 `max(dp[1], dp[2], dp3[3]) + 1`이라고 할 수 있다.

| i  | 0 | 1 | 2 | 3| 4 | 5 |
| :-:| :-: | :-: | :-: | :-:| :-: | :-: |
|`seq`| 0 | 20 | 30 | 10 | 40 | 35 |
|`dp`| 0 | `1` | `dp[1] + 1 = 2` | `1` | `max(dp[1], dp[2], dp[3]) + 1` | `max(dp[1], dp[2], dp[3]) + 1` |

이를 C++ 코드로 바꿔보면 아래와 같다.

```cpp{lineNos = false}
vector<int> seq{0, 20, 30, 10, 40, 35};
vector<int> dp(seq.size() + 1, 0);

for (int i = 1; i <= seq.size(); ++i) {
  // 이번 순회에서 dp[i]를 업데이트 할 것이고, 그 기본값은 자기 자신만이 LIS인 1
  dp[i] = 1;

  // 이전 dp들을 읽고, seq과 비교하며 연장할수 있는지 여부를 확인함
  for (int j = 0; j <= i; ++j) {
    if (seq[j] > seq[i]) {
      // 자기 자신과, seq[j]를 마지막으로 하는 LIS의 길이를 연장한것 중 최대
      dp[i] = max(dp[i], dp[j] + 1) 
    }
  }
}
```

알고리즘과 코드를 보면 알겠지만, 이 알고리즘의 복잡도는 $O(N^2)$으로 비효율적이다.  

이게 $N^2$이라는 비효율적인 복잡도를 가진 이유는, **매 순회마다 불필요하게 처음부터 다시 훑어 검사하기 때문** 이다.

어떤 `dp` 값은 바로 이전의 값에서 연장된 값이므로 검사하지 않을 수도 있는데, 이를 어떻게 이용할 방법은 없을까?

## 이분 탐색을 이용하여 구하기

이전 알고리즘에서 매 순회마다 `seq[0]` ~ `seq[i - 1]`을 훑어본 이유는, `seq[i]`보다 작은 `seq[j]`를 가지는 `j`들 중, 가장 큰 `dp[j]`를 찾기 위함이었다.

만일, `dp[j] = k`를 만족하는 `j` 중, `seq[j]`의 값이 가장 작은 `j`만 *어디엔가* 저장해 놓으면, 나중에 `dp[i] (i>j)`를 계산할 때, 그 값들만 참조하면 `dp[i]`의 값을 쉽게 알 수 있지 않을까?

여기서 새로운 배열 `tails`를 도입한다.

{{<admo title="`tails`의 정의">}}
`tails[i]`는, 길이 `i`인 증가 부분 수열의 마지막 값 중, 가장 작은 값을 의미한다.
{{</admo>}}


마찬가지로 예를 들어 `seq = {20, 30, 10, 40, 35}`이 있다고 하자.

알고리즘은 아래와 같다.
1. 처음에 빈 배열 `tails = {}` 로 시작한다.
2. `seq`의 각 요소 `seq[i]`를 순서대로 처리한다.
    * `seq[i]`가 `tails`의 마지막 값 보다 크면, `tails`에 추가한다.
    * 그렇지 않으면, `tails`에서 `seq[i]` 이상인 값 중 **가장 작은 값**을 찾아 치환한다.

==이 과정을 통해 `tails`는 항상 **정렬된 상태**가 유지되며, 또한 **`tails`의 길이는 현재까지의 LIS의 길이**와 동일하다.==

예를 들어 `i = 1`일 때, 
`tails`를 보았더니, 비어 있으므로 그냥 `seq[1] = 20` 값을 업데이트한다.

`i = 2`일 때,
길이가 2인 증가 부분 수열의 마지막 값 중 가장 작은 값은 

# LIS 구하기

```cpp
#include <iostream>
int main() {

}
```

# 참고 문헌

* [Longest increasing subsequence/Wikipedia](https://en.wikipedia.org/wiki/Longest_increasing_subsequence)
* [최장 증가 부분 수열/나무위키](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4)
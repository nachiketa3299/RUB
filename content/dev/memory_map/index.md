---
date: 2025-02-24
title: 메모리 레이아웃에 대해
toc: true

draft: true
---

# 개요

코드 영역이니 데이터 영역이니 들어본 적 많지 않은가? 

그런데 이런 것들은 요새 IDE 같은 것들이 너무 잘 숨겨주기 때문에 개념적으로나 알지, 실제로 이것들이 무엇인지는 아리송할 때가 좀 있었다.

그래서 문자열 리터럴에 대해서 공부하는 김에 날을 잡고 이것의 실체가 무엇인지 자료 조사를 좀 진행해 보았다.

컴파일 과정의 결과로 디스크에 저장되는 바이너리 파일에 프로그램이 실행 시간에 어떻게 작동될지에 대한 정보가 모두 구조화된 데이터로 기술되어 있다. 그리고 이것이 메모리에 또 적절한 방식으로 적재되면 실행 시간이 시작된다.

바이너리 파일은 운영체제 별로 그 구조가 다르기 때문에 가장 많이 쓰이는 윈도우즈 시스템 기준으로 조사를 진행하였다.

# 윈도우즈 PE 파일이란?

PE(Portable Executable)은 윈도우즈 시스템에서 실행 파일의 포맷이다. `.exe`, `.dll`, `.sys` 들이 PE 파일이다.[^1]

[^1]: 리눅스 시스템에서는 ELF 포맷이 유명하다.

PE 파일에는 여러 **섹션**들이 존재하며, PE 파일이 메모리에 적재되어 실행될 때 필요한 정보들이 기술되어 있다.

# PE 파일의 섹션 구분

디스크에 저장된 PE 파일을 뜯어보면, 다음과 같은 섹션 구분이 있다.[^2]

[^2]: 이것 말고도 매우 많은 정보가 있으니, 궁금하면 찾아 보시라.

* 코드/텍스트 영역 (`.text`)
* 읽기 전용 데이터 영역 (`.rdata`)
* 초기화된 전역/정적 데이터 영역 (`.data`)
* 초기화되지 않은 전역/정적 데이터 영역(`.bss`)
* 임포트 데이터 (`.idata`)
* 내보낸 데이터 (`.edata`)

순서는 *일반적으로* 저런 것 같다. 순서를 커스텀 할 수도 있는 모양이며, 순서는 그렇게 중요한 내용이 아닌 것 같기도 하다. 중요한 것은 각 섹션이 담고 있는 정보가 무엇이냐는 것이다.

`.text` 영역이 파일 오프셋 값이 가장 작고, 그 다음 섹션일 수록 오프셋 값이 커지는 구조이다.

이 바이너리 파일을 실행시키기로 결정하면, 전체 파일이 로더에 의해 메모리에 적재된다. 그러면 이러한 섹션 정보를 토대로 메모리에 다음처럼 배치된다.

* 스택 메모리 영역 <sup>높은 주소에서 낮은 주소로 확장</sup>
* 힙 메모리 영역 <sup>낮은 주소에서 높은 주소로 확장</sup>
* 초기화되지 않은 전역/정적 데이터 영역(`.bss`)
* 초기화된 전역/정적 데이터 영역 (`.data`)
* 읽기 전용 데이터 영역 (`.rdata`)
* 코드/텍스트 영역 (`.text`)

이것도 순서가 완벽히 중요해 보이지는 않는다. 로더마다 방식이 조금씩 다르다고도 하는 것 같다. 

위 리스트에서 가장 위에 있는 것이 제일 높은 메모리 주소에 배치되고, 아래로 갈 수록 낮은 메모리 주소에 배치된다. 그리고 이 때 메모리 주소는 가상 메모리 주소이다.

또, 스택 메모리 영역은 낮은 메모리 주소에서 높은 메모리 주소로 확장되고, 힙 메모리 영역은 높은 메모리 주소에서 낮은 메모리 주소로 확장된다.

PE 파일, 즉 바이너리를 제작하는 시점이 **컴파일 시점**이며, 이런 바이너리가 메모리에 배치되어 실행되는 시점이 **실행 시점**이다.

# 간단한 프로그램으로 분석해보기

다음과 같은 간단한 프로그램이 있다고 하자.

{{< hls source="assets/example.c" syntax=c >}}

PE 파일을 뜯어보기 위해 여러 솔루션이 있지만, 나는 [horsicq/XPEViewer](https://github.com/horsicq/XPEViewer)를 사용하였다.

프로그램의 기본적인 구조 파악은 디버그 심볼 없이도 가능하나, 함수 등의 이름을 보고 싶다면, 디버그 심볼을 포함한 채로 컴파일 해야 한다.

![](assets/pe_visulaization.png "각 섹션의 시각화 (아주 긴 디버그 심볼들이 포함되어 있다.)")

### `.text` 섹션

실행 가능한 코드가 저장되는 곳이다.

CPU가 실행할 실제 명령어들이 이 섹션에 저장된다.

{{< hls source="assets/example.c" syntax=c >}}

전체 코드가 컴파일된 출력물인 실행 가능한 기계어들이 적재되는 곳이라고 보면 된다.

바이너리 데이터를 어셈블리 뷰로 보는 것이 가장 합리적인 영역이다.
프로그램이 어떻게 작동하는지 어셈블리로 확인할 수 있다.

### `.data` 섹션 (Initialized Data Segment)

*초기화된* 전역 변수들이 저장된다.

{{< hls source="assets/example.c" syntax=c options="hl_lines=3">}}

`g_init`은 초기화된 전역 변수로, `.data` 섹션에 저장된다.

### `.bss` 섹션 (Uninitialized Data Segment)

*초기화되지 않은* 전역 변수들이 저장된다.

{{< hls source="assets/example.c" syntax=c options="hl_lines=4">}}

`g_non_init`은 초기화되지 않은 전역 변수로, `.bss` 섹션에 저장된다.

### `.rdata` 섹션

{{< hls source="assets/example.c" syntax=c options="hl_lines=13 14 16">}}

읽기 전용 데이터로, 주로 문자열 리터럴이나 상수 값들이 저장된다.

`"String in Data Section 0"` 문자열 리터럴은 반복되는데, 반복되는 문자열은 컴파일러가 최적화 하여 한 번만 저장한다.

때문에 문자열 포인터 `str_ptr0`과 `str_ptr1`은 같은 곳을 가리키고 있다.

### `.idata` 섹션

동적 라이브러리에서 호출할 함수들의 정보가 저장된다.

# 참고 문헌

- [text, data, bss, and dec/Fahad Mirza](https://mirzafahad.github.io/2021-05-08-text-data-bss/)
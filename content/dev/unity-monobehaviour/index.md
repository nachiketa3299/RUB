---
title: "[유니티] 컴포넌트 시스템"
toc: true
draft: false
---

# 게임 오브젝트

* 유니티의 게임오브젝트 클래스는 씬에 존재할 수 있는 모든 것을 나타낸다.
* 게임 오브젝트는 유니티의 씬을 위한 빌딩 블록이다. 컴포넌트는 게임 오브젝트의 모양과 기능을 결정하고, 게임 오브젝트는 컴포넌트의 컨테이너이다.
* 스크립팅에서 `GameObject`클래스는 코드에서 게임 오브젝트 찾기, 연결, 메시지 전송, 게임 오브젝트에 연결된 컴포넌트 추가 또는 제거, 씬 상태와 관련된 값 설정 등의 작업을 수행할 수 있는 메서드 컬렉션을 제공한다.

## 씬 상태 프로퍼티

* 스크립트를 사용하여 씬에서의 게임 오브젝트의 상태와 관련된 많은 프로퍼티를 수정할 수 있다. 이 프로퍼티들은 에디터에서 게임 오브젝트를 선택했을 때 인스펙터의 상단 근처에 표시되는 컨트롤에 해당한다. 이 컨트롤은 특정 컴포넌트와 관련이 없으며, 상단의 게임 오브젝트 인스펙터에서 컴포넌트 목록 위에 표시된다.
  * 모든 게임 오브젝트는 씬 내 게임오브젝트 상태와 관련하여 인스펙터 상단의 컨트롤 세트를 공유하며, 게임 오브젝트의 스크립팅 API를 통해 제어할 수 있다.

### 활성 상태

* 게임 오브젝트는 기본적으로 활성 상태이지만, 비활성화하여 게임 오브젝트에 연결된 모든 컴포넌트를 해제할 수 있다. 
* 일반적으로 비활성 게임 오브젝트는 눈에 보이지 않고, `Update`또는 `FixedUpdate`같은 정상적인 콜백이나 이벤트를 수신하지 않는다.
* 게임오브젝트의 활성 상태는 체크박스로 표시되며, `GameObject.SetActive`를 사용하여 제어할 수 있다.
* `GameObject.activeSelf`를 사용하여 게임 오브젝트의 현재 활성 상태를 읽을 수 있다.
* `GameObject.activeInHierarchy`를 사용하여 게임 오브젝트가 실제로 씬에서 활성 상태인지 판독한다. 
  * 게임 오브젝트가 실제로 활성 상태인지에 대한 여부는 자신의 활성 상태에 더해 모든 부모 오브젝트의 활성 상태에 따라 결정되기 때문이다. ==부모가 활성화되어 있지 않은 경우, 자체 활성화 설정에도 불구하고 활성화되지 않는다.==

### 정적 상태

* 전역 조명, 오클루전, 배칭, 내비게이션, 반사, 프로브와 같은 일부 Unity 시스템은 게임 오브젝트의 정적 상태에 의존한다.
* `GameObjectUtility.SetStaticEditorFlags`를 사용하여 게임 오브젝트를 정적으로 간주하는 유니티 시스템을 제어할 수 있다.

### 태그 및 레이어

* 태그는 씬에서 게임 오브젝트 타입을 표시 및 식별하는 방식을 제공하고, 레이어는 렌더링 또는 물리 충돌 같은 특정 빌트인 동작에 게임 오브젝트 그룹을 포함하거나 제외하는 유사하면서도 차별화되는 방식을 제공한ㄷ.
* `GameObject.tag`및 `GameObject.layer` 프로퍼티를 사용하여 스크립트를 통해 태그와 레이어 값을 수정할 수 있다.
  * 또한, 태그의 존재 여부에 대한 검사를 포함하며, 메모리 할당을 유발하지 않는 `CompareTag` 메서드를 사용하여 게임 오브젝트의 태그를 효과적으로 확인할 수 있다.

## 컴포넌트 추가 제거

* 런타임에 컴포넌트를 추가하거나 제거할 수 있고, 이는 게임 오브젝트를 절차적으로 생성하거나 동작 방식을 수정할 때 유용하다.
* 손상을 일으키지 않고 스크립트를 통해 컴포넌트와 일부 타입의 빌트인 컴포넌트를 `enable` 또는 `disable` 상태로 만들 수 있다.
* 런타임 컴포넌트 추가의 가장 좋은 방법은 `AddComponent<Type>`이며, 컴포넌트를 제거하려면 컴포넌트에 대해 `Object.Destroy` 메서드를 사용한다.

## 컴포넌트 접근

* 게임 오브젝트의 스크립트(컴포넌트)가 동일한 게임 오브젝트에 연결된 다른 컴포넌트에 액세스 해야 하는 경우가 많다. 이 때 `GetComponent` 메서드가 사용된다. `GetComponent`로 게임 오브젝트에 추가되지 않은 컴포넌트에 접근하려고 하면, `null`을 반환한다.

### 다른 오브젝트의 컴포넌트 접근

* 스크립트가 다른 게임 오브젝트의 스크립트를 참조해야 할 때가 있다.
* 가장 간단한 방법은 인스펙터에서 할당하고, `GetComponent`로 가져오는 것이다.
  * 인스펙터 할당용 참조는 `GameObject`일 수도 있고, 특정 컴포넌트가 있는 게임오브젝트로 제한하려면, 해당 컴포넌트로 선언할 수도 있다.

#### 런타임에 찾기

* 자식 게임 오브젝트 찾기
  * 자식 게임 오브젝트는 부모의 `Transform` 컴포넌트를 사용하여 검색할 수 있다.
  * **모든 게임 오브젝트는 암시적으로 `Transform`을 가지고 있다.**

```csharp
public class WaypointManager : MonoBehaviour 
{
  public Transform[] waypoints;
  void Start()
  {
    waypoints = new Transform[transform.childCount];
    int i = 0;
    foreach(Transform t in transform)
    {
      waypoints[i++] = t;
    }
  }
}
```

  * `Transform.Find` 메서드를 사용하면 특정 자식 메서드를 찾을 수도 있다.

## 메시지 전송 및 브로드캐스트

게임에서 캐릭터와 가장 가까운 아이템을 찾거나, 씬이 로드된 후 인스턴스화된 게임오브젝트를 참조하는 등, 미리 설정하는 것이 불가능한 경우도 있다.

이러한 경우 런타임에서 게임오브젝트 간에 레퍼런스를 찾고 메시지를 보낼 수 있다.

`BroadcastMessage`를 사용하면 해당 메서드를 구현해야 하는 위치를 구체적으로 지정하지 않고도 명명된 메서드를 호출할 수 있다.

특정 게임 오브젝트 또는 그 자식 게임 오브젝트의 모든 `MonoBehaviour`에 대해 명명된 메서드를 호출할 수도 있다. 원하는 경우 최소 하나의 리시버가 존재하고, 그렇지 않으면 오류가 생성되도록 지정할 수도 있다.

`SendMessage`는 좀 더 특정적이며, 게임 오브젝트 자체(자식 제외)에 대한 명명된 메서드만 호출한다.

`SendMessageUpward`는 다소 유사하지만, 게임 오브젝트와 모든 해당 부모에 대한 명명된 메서드를 호출한다.

## 이름이나 태그로 게임 오브젝트 찾기

게임 오브젝트 식별정보만 있으면 씬 계층구조의 어디에서든 게임오브젝트를 찾을 수 있다.
개별 오브젝트를 `GameObject.Find` 함수를 통해 이름으로 검색할 수 있다.
`GameObject.FindWithTag`나 `GameObject.FindGameObjectsWithTag` 메서드를 사용하여 태그로도 찾을 수 있다.

## 게임 오브젝트 생성 및 제거

`Instantiate` 메서드를 사용하면 게임 오브젝트를 생성할 수 있다. 이 때 메서드는 기존 오브젝트의 새 복사본을 만든다.

"프리팹 인스턴스화"에 대해 알아보라.

`Destroy` 메서드는 프레임 업데이트가 완료된 후 또는 선택적으로 짧은 시간 지연 후 오브젝트를 삭제한다. (`Destroy(gameObject, 0.5f)`)

`Destroy` 함수는 개별 컴포넌트도 파괴할 수 있으므로, `Destroy(this)`는 게임 오브젝트를 파괴한 것이 아니라, 이것이 호출된 컴포넌트를 파괴한 것이다.

# `MonoBehaviour`

* 모든 유니티 스크립트가 파생되는 기본 클래스
* 유니티 에디터에서 C# 스크립트를 생성하면 `MonoBehaviour`에서 자동으로 상속어 템플릿 스크립트를 제공함.
* 에디터에서 게임 오브젝트에 스크립트를 연결할 수 있는 프레임워크를 제공함.
* `Start`, `Update`와 같은 유용한 이벤트에 대한 연결을 제공함
* `MonoBehaviour` 스크립트 자체에서 에디터에 할당할 수 있는 공용 `Object` 필드를 정의하는 경우, 에디터 스크립트 애셋에서 이러한 필드에 대한 기본 레퍼런스를 설정할 수 있음.
  * 게임 오브젝트의 `MonoBehaviour` 인스턴스에 있는 레퍼런스와 기본 레퍼런스 사이에는 지속적인 링크가 존재하지 않으므로, 기본 레퍼런스를 변경하더라도 기존 게임 오브젝트에는 변경 사항이 자동으로 적용되지 않는다.
* `UnityEngine.Object`에서 상속되지 않는 다른 유형의 인스펙터 편집 가능 필드(공용 문자열 및 `int`필드)는 인스펙터에 기본 필드가 없다. 대신, 스크립트 자체에서 기본값을 가져온다.
* `MonoBehaviour` 클래스를 사용하면 코루틴을 관리할 수 있다.
* `MonoBehaviour`는 대규모 이벤트 메시지 컬렉션에 대한 액세스를 제공하며, 이를 통해 현재 프로젝트에서 발생하는 상황에 따라 코드를 실행할 수 있다.

# Object

UnityEngine 이름 공간에 존재하는 클래스로, 유니티가 에디터에서 참조할 수 있는 모든 객체의 기본 클래스 역할을 한다.

`UnityEngine.Object`에서 상속되는 클래스는 인스펙터의 필드로 드래그 앤 드롭하거나, 오브젝트 필드 옆에 있는 오브젝트 피커를 사용하여 선택하도록 해주는 특수 기능을 지원한다.

스크립트를 통해 자체 오브젝트를 생성하는 경우 Object에서 직접 상속하면 안되고, 목표에 맞는 더 잘 설계된 클래스에서 상속해야 한다.

예를 들어 게임 오브젝트에 추가할 수 있는 커스텀 컴포넌트를 작성하고 게임 오브젝트가 수행하는 작업을 제어하거나, 관련한 일부 기능을 제공하려면 `MonoBehaviour`에서 상속한다.

참고로 유니티의 `Object` 클래스와 .NET의 기본 `Object` 클래스와는 다른 것이므로 유의한다. 이름만 같을 뿐이다. 인스펙터에서 할당할 필요가 없는 클래스를 스크립트에 생성하려는 경우 여전히 .NET의 `System.Object` 클래스를 상속할 수 있다.

`Object` 클래스는 게임오브젝트, 컴포넌트, 머터리얼, 텍스쳐, 메쉬, 스프라이트 등을 비롯한 대부분의 유니티 빌트인 클래스에 대한 기본 클래스 역할을 한다. 즉, 인스펙터에서 이러한 모든 타입을 이 레퍼런스 필드에 드래그 앤 드롭 할 수 있다.
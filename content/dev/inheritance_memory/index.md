--- 
title: "[C++] 상속과 메모리 배치"
toc: true
date: 2025-03-11
---

# 메모리 배치

## 가상 함수가 없는 경우

상속 구조가 다음과 같다 치자:

```cpp{lineNos=false}
struct A {};
struct B: A {};
struct C: B {};
struct D: C {};
```

`D d{};`로 객체 `d`를 만들면, 상속 구조도의 맨 꼭대기부터 생성자가 호출된다.

메모리에는 다음 처럼 적재된다.

```
A 영역  <-- 낮은 주소
-----
B 영역
-----
C 영역
-----
D 영역  <-- 높은 주소
```

포인터로 객체를 가리키면 항상 객체의 시작 주소를 가리키며 이는 객체의 가장 높은 주소이다. 

포인터의 형식에 따라 객체의 시작부터 얼마만큼이 해당 형식에서 의미 있는 정보인지 판별한다.

예를 들어, `B` 형식의 포인터 `b` 로 `d`를 가리키면 다음과 같은 상황이 된다.

```
A 영역  <-- B* b
-----
B 영역
-----
X X X (여기부턴 안 보임 - 뭐가 어디까지 있는지 전혀 모름)
-----
X X X
```

이모양이니 `b`로 `D`에 있는 뭔가에 접근할 수 있을 리가 없다.

## 가상 함수가 있는 경우

이번에는 상속 구조가 다음과 같다고 치자:

```cpp{lineNos=false}
struct A { virtual foo() {} };
struct B: A {};
struct C: B {};
struct D: C {};
```

생성자 호출이나 메모리 적재 순서 등 다른 것은 동일하지만,
가상 함수가 하나라도 존재하면 다음처럼 RTTI 정보가 포함된다.

```
A 영역 [vptr] <-- 낮은 주소
------------
B 영역
------------
C 영역
------------
D 영역        <-- 높은 주소
```

객체 시작 위치에 가상 함수 테이블을 가리키는 포인터 vptr이 생성된다.
이 포인터가 가리키는 가상 함수 테이블에는, 가상 함수 호출이 들어왔을 때 실제로 어디에 있는 함수를 호출해야 하는가 매핑된 정보가 들어 있다.

마찬가지로 `B`형 포인터 `b`로 가리키면 다음과 같아진다.


```
A 영역 [vptr] <-- B* b
------------
B 영역
------------
X XX         (역시 여기부턴 안 보임)
------------
X XX       
```

여전히 `B` 밑으로 안보인다 하더라도, vptr이 가리키는 테이블에 전체 객체의 메타데이터가 들어 있으므로, `b`로 `foo`를 호출하더라도 최종적으로 오버라이드되어 호출되어야 하는 메서드의 위치를 알아낼 수 있다. vptr에서 룩업한다는 성능 비용을 지출해야 하지만.

==따지고 보면 vptr이 객체 지향의 "다형성"을 구현하는 핵심 장치임을 알 수 있다.== vptr이 있어서 우리는 기초 클래스의 포인터로 유도 클래스의 메모리 영역에 런타임에 접근할 수 있다.

### 다운 캐스팅

다운 캐스팅은 vptr이 존재하는 (RTTI 정보가 포함된) 객체에 대해서만 가능하다.

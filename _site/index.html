<!DOCTYPE html>
<html lang=" en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>resume</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="resume" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="안녕하세요, 게임 개발자 송재민입니다." />
<meta property="og:description" content="안녕하세요, 게임 개발자 송재민입니다." />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="송재민 RESUME" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="resume" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"안녕하세요, 게임 개발자 송재민입니다.","headline":"resume","name":"송재민 RESUME","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="송재민 RESUME" /><link rel="shortcut icon" type="image/x-icon" href="" />
  <link rel="stylesheet" href="/%20/assets/css/main.css" />

  <!-- Latex -->
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    type="text/javascript"></script>

  <!-- Mermaid -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'dark' });
    document.querySelectorAll('pre > code.language-mermaid').forEach((codeBlock) => {
      codeBlock.parentElement.outerHTML = `<pre class="mermaid">${codeBlock.textContent}</pre>`;
    });
  </script>

  <!--syntax-->
  <link href="../assets/css/syntax.css" rel="stylesheet" />
</head>

</head><body a=" auto">
	<main class="page-content" aria-label="Content">
		<div class="w">
			<header>
	<h1>송재민 RESUME</h1></header><ul><li>CONTACT</li><ul><li><a href="https://github.com/nachiketa3299">github/nachiketa3299</a></li></ul></ul><h1 id="소개">소개</h1>

<p>$latex text?$</p>

<p>(초안)
기술과 예술이 가장 적극적으로 만나는 게임이라는 영역에 관심이 많은 테크 + 인문돌이임을 강조</p>

<ul>
  <li>이메일 nachiketa3299@gmail.com</li>
  <li>깃허브</li>
  <li>블로그 <a href="https://argien.tistory.com/">Even Idiots Can Make Game</a></li>
</ul>

<h1 id="available-skills">Available Skills</h1>

<ul>
  <li>Unity 5(2D + 3D), Unreal Engine 4</li>
  <li>Git</li>
  <li>C/C++, C#, Python, Lua, Dart</li>
  <li>Visual Studio / Visual Studio Code</li>
  <li>Vim</li>
</ul>

<h1 id="참여-프로젝트">참여 프로젝트</h1>

<h2 id="grim-memories-프로젝트-2024년-9월--현재">“Grim Memories” 프로젝트 <sup><i>2024년 9월 ~ 현재</i></sup></h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/EZtdZAEcpg8?si=08tsFxncRMNzdaYe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<ul>
  <li>팀 규모: 7명</li>
  <li>게임 개요:
    <ul>
      <li>1인칭 시점의 공포 테마 방 탈출 게임</li>
      <li>선형적인 스토리와 시네마틱 연출을 체험할 수 있다.</li>
      <li>동일한 공간을 두 가지 버전으로 체험할 수 있게 하는 것이 특장점.</li>
    </ul>
  </li>
  <li>직책: 메인 프로그래머, 프로젝트 매니저</li>
  <li>목표: Itch.io와 Steam에 게임 데모 출시</li>
</ul>

<h3 id="주요-구현-사항">주요 구현 사항</h3>

<ul>
  <li>프로젝트 매니저로서 전체 개발 업무 배분 및 일정 관리</li>
  <li>상주 씬과 월드 씬을 분리하여 협업 작업 워크플로우 구축</li>
  <li>캐릭터 컨트롤러 및 상호작용 시스템 구현</li>
  <li>전체 사운드 프로그래밍</li>
</ul>

<h4 id="1인칭-캐릭터-컨트롤러-및-상호작용-시스템-구현">1인칭 캐릭터 컨트롤러 및 상호작용 시스템 구현</h4>

<p>조용하고 정적인 공간에서 대부분의 플레이가 진행되는 1인칭 시점의 캐릭터 컨트롤러를 구현하는 것이 과제였습니다. 기본 이동, 앉기, 걷기 등에 따라 이동의 효과 (카메라 흔들림, 사운드)가 다르게 느껴져야 했습니다.</p>

<p><img src="../Images/LocomotionSystem.jpg" alt="Locomotion System" /></p>

<p>이동의 4가지 배타적 상태를 명확히 규정한 후, 메인 이동 컴포넌트(<code class="language-plaintext highlighter-rouge">LocomotiveAction</code>)에서 상태 변경을 관리하였습니다.</p>

<p>아래처럼 옵저버 패턴을 활용하여 컴포넌트간 커플링을 최대한 줄이는 것이 목표였습니다. 각 컴포넌트는 자신이 관심 있는 이벤트만 구독하면 되고, 이벤트를 발생시키는 주체는 누가 자신을 구독하는지 몰라도 상관 없습니다.</p>

<p>예를 들어 이동 상태가 일반(<code class="language-plaintext highlighter-rouge">NormalJog</code>)에서 앉아 이동(<code class="language-plaintext highlighter-rouge">CrouchedJog</code>)로 바뀌면, 이동 충격이 발생하는 주기가 길어집니다. 각 이동 충격에는 <em>발소리 재생</em>과 <em>카메라 떨림</em>이라는 사건이 발생합니다.</p>

<p>추가적으로 Unity에 이미 존재하는 <code class="language-plaintext highlighter-rouge">Cinemachine</code> 관련 컴포넌트들을 카메라의 진동과 노이즈를 에디터에서 쉽게 On/Off 하거나 수치를 조정할 수 있도록 구현하였습니다.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/wIU7-DIbJHs?si=O6OLzsyhpoMB1-HY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>(각 상태별 이동 충격의 발생을 디버그 모드에서 시각화)</p>

<h4 id="interaction-시스템-구현">Interaction 시스템 구현</h4>

<ul>
  <li><em>무언가</em>가 가진 고유 기능을 작동시키기</li>
  <li><em>무언가</em>를 인벤토리에 넣기</li>
  <li><em>무언가</em>를 손에 장착하고 <em>다른 무언가</em>에 사용하기</li>
</ul>

<p>위와 같이 약간 모호하게 정의된 기획적 개념<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>들을 Interact(Activate/Collect) + Use 라는 구체적인 개념으로 재정의한 후 구현하였습니다. 이 과정에서 시스템 기획자와 많은 의사 소통이 있었습니다. 어려운 과정이었지만, 결과물을 바탕으로 게임의 시스템을 확장해 나갈 수 있어서 보람찬 일이었습니다.</p>

<p>또한 상호작용 가능한 오브젝트의 다음과 같은 문제를 해결해야 했습니다.</p>

<ul>
  <li>상호작용 오브젝트는 $n$개의 MeshRenderer가 위계 구조를 형성하고 있을 수 있다.</li>
  <li>상호작용을 감지하는 콜라이더는 상호작용 오브젝트의 메쉬와 상관 없을 수도 있다.</li>
  <li>상호작용 오브젝트는 공유하는 상태도 있지만, 기본적으로 구체적인 오브젝트마다 전이하는 상태와 그 행동이 매우 다르다.</li>
</ul>

<p>또한 상호작용 가능한 오브젝트의 <em>(1) 메쉬가 단일 오브젝트가 아닐 가능성</em>에 대응하고, <em>(2) 상호작용을 감지하는 콜라이더는 메쉬와 분리될 수 있게</em> 하면서, <em>(3) 기본적으로 자기 자신의 상태를 전반적으로 관리</em>하게끔 하는 상호작용 오브젝트의 기초 클래스 <code class="language-plaintext highlighter-rouge">InteractableBase</code>를 작성하는 것이 주요한 과제였습니다.</p>

<p>상호작용 오브젝트마다 명확히 다른 요구사항이 존재했고, 이것들이 자주 변경되었기 때문에, 에디터에서 각 컴포넌트들의 직렬화된 참조를 지정하는 것이 관리의 용이성 측면에서 나았습니다.</p>

<p><img src="/Images/InteractableExample.png" alt="Interactable Editor Example" /></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/jboTbFeA7Ys?si=RhgfaL5SJVG6ItEp" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>(완성된 상호작용 시스템의 모습)</p>

<h4 id="fmod-unity를-활용한-사운드-시스템-구축">FMOD Unity를 활용한 사운드 시스템 구축</h4>

<ul>
  <li>사운드 디자이너 분과 더 질좋은 사운드 경험을 위해 FMOD Unity를 사용하기로 협의</li>
</ul>

<p>FMOD Event 디자인 일부에 참여하였고, 전체 게임의 사운드 프로그래밍을 담당하였습니다.</p>

<p>예를 들어, 재질과 이동 상태에 따라서 발소리가 달라져야 했는데, 이를 유니티에서 하드코딩 하지 않고 FMOD Event를 사용하여 사운드 디자이너의 워크플로우와 프로그래머의 워크플로우가 충돌하지 않고 서로의 일에 집중할 수 있도록 만들었습니다.</p>

<p>또한 사운드 프로그래머로서 각기 다른 FMOD Event들이 언제 인스턴스화되고 언제 <code class="language-plaintext highlighter-rouge">release</code>될 지 관리하였습니다.</p>

<p><img src="./Images/FMOD%20Example.png" alt="FMOD Example" />
(바닥의 재질과 이동 상태에 따라서 다른 발소리 세트를 재생하도록 디자인된 FMOD Event의 예시)</p>

<h4 id="localization-협업-시스템-구축">Localization 협업 시스템 구축</h4>

<p>Unity의 Localization 패키지를 이용하여 스트링 테이블로 최종 플레이어에게 전달되는 모든 문자열을 관리하였고, 해당 문자열 테이블을 Google SpreadSheet로 Push / Pull 할 수 있게 만들어 기획자분들이 쉽게 내용을 변경하고 게임에 적용할 수 있게 시스템을 구축하였습니다.</p>

<p><img src="/Images/LocalizationExample.png" alt="Localization" /></p>

<hr />

<h2 id="munchkin-프로젝트-2024년-6월--8월">“Munchkin” 프로젝트 <sup><i>2024년 6월 ~ 8월</i></sup></h2>

<ul>
  <li>직책: 팀장, 메인 프로그래머, 메인 기획자</li>
  <li>팀 규모: 4명</li>
  <li>게임 개요
    <ul>
      <li>&lt;Getting Over It&gt;에서 영감을 얻은 고난이도 2.5D 플랫포밍 게임</li>
      <li>“달걀 → 병아리 → 닭”이라는 고유의 생애주기를 갖는 캐릭터를 주인공으로 내세운 점이 특이점. 실패가 빈번한 어려운 게임이지만 “가장 가까운 알”에서 “병아리” 상태로 부활한다는 고유의 메커니즘으로 게임을 클리어할 수 있도록 기획.</li>
    </ul>
  </li>
  <li>목표: Itch.io에 게임 데모 출시</li>
  <li>전체 기획서 링크
    <ul>
      <li><a href="https://substantial-panther-211.notion.site/9a3725e57d7b41a5891e7c0fe1c0d3d5?pvs=4">전체 콘셉트</a></li>
      <li><a href="https://substantial-panther-211.notion.site/a19b8ac4a4904419a9b0a693b6b12ae4?pvs=4">기획 용어 정리</a></li>
      <li><a href="https://substantial-panther-211.notion.site/61fe3ea8d1bb4b14b68105bb148ddb04?pvs=4">게임의 생애주기</a></li>
      <li><a href="https://substantial-panther-211.notion.site/edf4c88bdcd14b2aa3114abfacb01176?pvs=4">게임플레이 서사</a></li>
      <li><a href="https://substantial-panther-211.notion.site/853508194aae4672a58a6a2715d4f414?pvs=4">플레이어 입력</a></li>
      <li><a href="https://substantial-panther-211.notion.site/243480d1e8b44ada8704811f08be5de6?pvs=4">캐릭터 기획</a></li>
      <li><a href="https://substantial-panther-211.notion.site/3dd5857436dc4a5abdaf021cf439e263?pvs=4">장치와 함정 기획</a></li>
      <li><a href="https://substantial-panther-211.notion.site/5553f23380f448b7a10b1157e1f28512?pvs=4">레벨과 스테이지 기획</a></li>
    </ul>
  </li>
</ul>

<h3 id="주요-구현-사항-1">주요 구현 사항</h3>

<h4 id="주요-기술적-설계-의사결정-주도">주요 기술적 설계 의사결정 주도</h4>

<ul>
  <li>게임 플레이 내내 절대 언로드되지 않는 상주 씬(Persistent Scene)에 월드 씬을 런타임에 Additive 모드로 로드 / 언로드하여 게임플레이 월드를 구축
    <ul>
      <li>이를 위해, 씬 간의 물리적 인접 관계를 에디터에서 그래프로 표현 후, 런타임에 해당 그래프를 탐색하여 필요한 씬을 로드하고 언로드하는 시스템을 구축.</li>
    </ul>
  </li>
  <li>레벨 디자인에서 수정이 용이하도록, Tilemap의 GameObject 브러시를 이용하여 블럭으로 모듈화된 분할 월드 씬 개발</li>
</ul>

<h4 id="동적-additive-씬-로딩-시스템-구축">동적 Additive 씬 로딩 시스템 구축</h4>

<p>메트로배니아 장르의 게임 처럼 거대한 맵에서 플랫포밍을 하는 게임으로, 플레이어에게 가시적인 로딩이 없었으면 좋겠다고 생각했습니다. 그래서 게임 월드를 작은 씬들로 쪼개, 필요에 따라 런타임에 로드하고 언로드하는 방식을 구현하려 하였습니다.</p>

<p>여기서 씬의 로드가 필요한 경우는 다음과 같습니다.</p>
<ul>
  <li>주요 오브젝트(예: 캐릭터)가 현재 존재하는 씬과, 해당 씬과 깊이 $n$으로 인접한 씬</li>
</ul>

<p>위와 같은 상태가 아닌 씬들은 모두 언로드가 필요합니다.</p>

<p>씬의 로드가 필요한 오브젝트는 “캐릭터”와 “알” 이었습니다. 캐릭터가 사망 처리된 경우, 영혼으로 변하여 “알”로 지형을 무시한 채 이동하여 부활할 필요가 있기 때문이었습니다. (여기서 “알”은 Non-Kinematic Rigidbody 오브젝트입니다.)</p>

<p>캐릭터와 알 모두 다음과 같은 요청을 보내는 상황이라고 생각하였습니다.</p>

<blockquote>
  <p>내가 현재 존재하는 씬으로부터, 논리적 거리가 $n$이하인 씬들은 로드되어 있어야 하고, 그렇지 않은 씬들은 다른 오브젝트가 요청을 보내지 않았다면 언로드해도 괜찮아.</p>
</blockquote>

<p>이를 위해 씬 로드/언로드 요청을 보내는 <code class="language-plaintext highlighter-rouge">SceneLoadTrigger</code>를 작성하였습니다. 이 스크립트는 해당 스크립트가 부착된 오브젝트가 어떤 씬의 경계<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">2</a></sup>에 들어갈 때, 해당 씬을 기준으로 설정된 거리 이내로 인접한 씬들을 로드해야 한다고 요청을 보냅니다.</p>

<p>그리고 다수의 <code class="language-plaintext highlighter-rouge">SceneLoadTrigger</code>들의 요청을 취합하여 최종적으로 씬 로드/언로드 연산을 수행하는 싱글턴 클래스 <code class="language-plaintext highlighter-rouge">SceneLoadManager</code>를 작성하였습니다.</p>

<p>씬 로드 / 언로드는 비동기 연산(<code class="language-plaintext highlighter-rouge">AsyncOperation</code>)이기 때문에 여러 프레임에 걸쳐 이뤄지는 일이지만, 어떤 씬을 로드하라 / 언로드하라 라는 요청은 “주요 오브젝트가 씬의 경계에 들어갈 때”라는 <em>물리적 사건</em>에 의해 일어나므로 이론적으로 중복되는 요청이 발생하기 쉬웠습니다.</p>

<p>예를 들어 씬 A가 이미 로드/언로드 연산이 진행 중인 씬에 대해서 또다시 로드/언로드 연산이 요청되는 경우를 처리해야 했습니다.</p>

<hr />

<h2 id="alien-프로젝트-2024년-3월2024년-5월">“Alien” 프로젝트 <sup><i>2024년 3월~2024년 5월</i></sup></h2>

<ul>
  <li>팀 규모: 4명</li>
  <li>직책: 팀장, 메인 프로그래머, 메인 기획자</li>
  <li>목표: BIC 출품 위한 MVP 제작</li>
</ul>

<hr />

<h2 id="unreal-labs">Unreal Labs</h2>

<ul>
  <li>약 20명 규모의 Unreal 엔진 소스코드 분석 연구회</li>
  <li><code class="language-plaintext highlighter-rouge">ActorComponent</code> 팀에서 해당 기능을 분석</li>
  <li><a href="https://docs.google.com/presentation/d/19-R6U1GwiAnyQH91bM8MlbIXAxXcxeDGW7L3T93jJ6w/edit?usp=sharing">발표자료</a></li>
  <li>연구 학생으로 참여</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">hello</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>예를 들어, 기획에는 소개된 세 개념들이 상호 배타적인 것인지에, 아니면 서로 중복되는 영역이 있는지에 대한 내용이 존재하지 않았었는데, 회의와 질의응답을 통해 이를 명확하게 하는 과정이 있었습니다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>씬마다 경계를 의미하는 Trigger Collider를 부착하였습니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

		</div>
	</main>
</body>

</html>